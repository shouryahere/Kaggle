"""
Google API Tools - Real implementations for Calendar, Gmail, Tasks, and Photos

This module contains the actual Google API integrations.
Requires: token.json file generated by setup_google_auth.py
"""

import os
import logging
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
import base64
from email.mime.text import MIMEText
try:
    from zoneinfo import ZoneInfo
except ImportError:
    from backports.zoneinfo import ZoneInfo
import time

# Configure logging
logger = logging.getLogger("LifeAdminAgent.GoogleTools")

# Path to token file
TOKEN_FILE = os.path.join(os.path.dirname(__file__), '..', 'token.json')

def _get_credentials():
    """Load credentials from token.json"""
    from google.oauth2.credentials import Credentials
    from google.auth.transport.requests import Request
    
    if not os.path.exists(TOKEN_FILE):
        raise FileNotFoundError(
            f"token.json not found! Please run 'python setup_google_auth.py' first "
            f"to authenticate with Google APIs. Expected path: {TOKEN_FILE}"
        )
    
    creds = Credentials.from_authorized_user_file(TOKEN_FILE)
    
    # Refresh if expired
    if creds and creds.expired and creds.refresh_token:
        creds.refresh(Request())
        # Save refreshed token
        with open(TOKEN_FILE, 'w') as token:
            token.write(creds.to_json())
    
    return creds


def _get_service(api_name: str, version: str):
    """Build a Google API service client"""
    from googleapiclient.discovery import build
    
    creds = _get_credentials()
    
    # Photos API needs static_discovery=False
    if api_name == 'photoslibrary':
        return build(api_name, version, credentials=creds, static_discovery=False)
    
    return build(api_name, version, credentials=creds)


# =============================================================================
# GOOGLE CALENDAR API
# =============================================================================

def create_calendar_event(
    title: str,
    start_time: str,
    duration_hours: float = 1.0,
    description: str = "",
    location: str = "",
    reminder_minutes: int = 30,
    calendar_id: str = "primary"
) -> dict:
    """
    Creates a real Google Calendar event.
    
    Args:
        title: Event title/summary
        start_time: Start time in ISO format (e.g., "2025-12-15T10:00:00") or natural format
        duration_hours: Event duration in hours (default: 1 hour)
        description: Event description/notes
        location: Event location
        reminder_minutes: Minutes before event to send reminder
        calendar_id: Which calendar to use (default: primary)
    
    Returns:
        Dictionary with event details including the link to the event
    """
    logger.info(f"[TOOL] create_calendar_event: {title} at {start_time}")
    
    try:
        service = _get_service('calendar', 'v3')
        
        # Parse start time
        if 'T' in start_time:
            start_dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
        else:
            # Try to parse various formats
            start_dt = datetime.fromisoformat(start_time)
        
        end_dt = start_dt + timedelta(hours=duration_hours)
        
        # Get local timezone - use Asia/Kolkata for IST
        local_tz = 'Asia/Kolkata'
        
        # Build event body
        event = {
            'summary': title,
            'location': location,
            'description': description,
            'start': {
                'dateTime': start_dt.isoformat(),
                'timeZone': local_tz,
            },
            'end': {
                'dateTime': end_dt.isoformat(),
                'timeZone': local_tz,
            },
            'reminders': {
                'useDefault': False,
                'overrides': [
                    {'method': 'popup', 'minutes': reminder_minutes},
                ],
            },
        }
        
        # Create the event
        created_event = service.events().insert(
            calendarId=calendar_id,
            body=event
        ).execute()
        
        logger.info(f"[TOOL] Calendar event created: {created_event.get('id')}")
        
        return {
            "success": True,
            "event_id": created_event.get('id'),
            "title": created_event.get('summary'),
            "start": created_event.get('start', {}).get('dateTime'),
            "end": created_event.get('end', {}).get('dateTime'),
            "location": created_event.get('location', ''),
            "html_link": created_event.get('htmlLink'),
            "message": f"âœ… Calendar event '{title}' created successfully!"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e), "hint": "Run setup_google_auth.py first"}
    except Exception as e:
        logger.error(f"[TOOL] Calendar error: {e}")
        return {"success": False, "error": str(e)}


def list_calendar_events(
    max_results: int = 10,
    time_min: str = None,
    calendar_id: str = "primary"
) -> dict:
    """
    List upcoming calendar events.
    
    Args:
        max_results: Maximum number of events to return
        time_min: Start time for events (ISO format), defaults to now
        calendar_id: Which calendar to use
    
    Returns:
        Dictionary with list of events
    """
    logger.info(f"[TOOL] list_calendar_events: max={max_results}")
    
    try:
        service = _get_service('calendar', 'v3')
        
        if not time_min:
            time_min = datetime.utcnow().isoformat() + 'Z'
        
        events_result = service.events().list(
            calendarId=calendar_id,
            timeMin=time_min,
            maxResults=max_results,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        
        events = events_result.get('items', [])
        
        event_list = []
        for event in events:
            start = event['start'].get('dateTime', event['start'].get('date'))
            event_list.append({
                "id": event['id'],
                "title": event.get('summary', 'No title'),
                "start": start,
                "location": event.get('location', ''),
                "link": event.get('htmlLink', '')
            })
        
        return {
            "success": True,
            "count": len(event_list),
            "events": event_list,
            "message": f"ðŸ“… Found {len(event_list)} upcoming events"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Calendar list error: {e}")
        return {"success": False, "error": str(e)}


# =============================================================================
# GMAIL API
# =============================================================================

def create_gmail_draft(
    to: str,
    subject: str,
    body: str,
    cc: str = None,
    bcc: str = None
) -> dict:
    """
    Creates a real Gmail draft.
    
    Args:
        to: Recipient email address
        subject: Email subject line
        body: Email body content (plain text)
        cc: CC recipients (comma-separated)
        bcc: BCC recipients (comma-separated)
    
    Returns:
        Dictionary with draft details
    """
    logger.info(f"[TOOL] create_gmail_draft: to={to}, subject={subject}")
    
    try:
        service = _get_service('gmail', 'v1')
        
        # Create the email message
        message = MIMEText(body)
        message['to'] = to
        message['subject'] = subject
        if cc:
            message['cc'] = cc
        if bcc:
            message['bcc'] = bcc
        
        # Encode the message
        raw = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
        
        # Create the draft
        draft = service.users().drafts().create(
            userId='me',
            body={'message': {'raw': raw}}
        ).execute()
        
        logger.info(f"[TOOL] Gmail draft created: {draft.get('id')}")
        
        return {
            "success": True,
            "draft_id": draft.get('id'),
            "message_id": draft.get('message', {}).get('id'),
            "to": to,
            "subject": subject,
            "body_preview": body[:200] + "..." if len(body) > 200 else body,
            "message": f"âœ… Draft created! Open Gmail to review and send."
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Gmail error: {e}")
        return {"success": False, "error": str(e)}


def send_email(
    to: str,
    subject: str,
    body: str,
    cc: str = None
) -> dict:
    """
    Send an email directly (use with caution - creates draft first is safer).
    
    Args:
        to: Recipient email address
        subject: Email subject line
        body: Email body content
        cc: CC recipients
    
    Returns:
        Dictionary with send status
    """
    logger.info(f"[TOOL] send_email: to={to}, subject={subject}")
    
    try:
        service = _get_service('gmail', 'v1')
        
        message = MIMEText(body)
        message['to'] = to
        message['subject'] = subject
        if cc:
            message['cc'] = cc
        
        raw = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
        
        sent = service.users().messages().send(
            userId='me',
            body={'raw': raw}
        ).execute()
        
        return {
            "success": True,
            "message_id": sent.get('id'),
            "to": to,
            "subject": subject,
            "message": f"âœ… Email sent to {to}!"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Gmail send error: {e}")
        return {"success": False, "error": str(e)}


# =============================================================================
# GOOGLE TASKS API
# =============================================================================

def list_task_lists() -> dict:
    """
    List all task lists in Google Tasks.
    
    Returns:
        Dictionary with task lists
    """
    logger.info("[TOOL] list_task_lists")
    
    try:
        service = _get_service('tasks', 'v1')
        
        results = service.tasklists().list(maxResults=10).execute()
        task_lists = results.get('items', [])
        
        return {
            "success": True,
            "count": len(task_lists),
            "task_lists": [
                {"id": tl['id'], "title": tl['title']}
                for tl in task_lists
            ],
            "message": f"ðŸ“‹ Found {len(task_lists)} task lists"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Tasks list error: {e}")
        return {"success": False, "error": str(e)}


def list_tasks(task_list_id: str = "@default", show_completed: bool = False) -> dict:
    """
    List tasks in a task list.
    
    Args:
        task_list_id: ID of the task list (use "@default" for default list)
        show_completed: Whether to include completed tasks
    
    Returns:
        Dictionary with tasks
    """
    logger.info(f"[TOOL] list_tasks: list={task_list_id}")
    
    try:
        service = _get_service('tasks', 'v1')
        
        results = service.tasks().list(
            tasklist=task_list_id,
            showCompleted=show_completed,
            maxResults=50
        ).execute()
        
        tasks = results.get('items', [])
        
        task_list = []
        for task in tasks:
            task_list.append({
                "id": task['id'],
                "title": task.get('title', ''),
                "status": task.get('status', ''),
                "due": task.get('due', ''),
                "notes": task.get('notes', '')
            })
        
        return {
            "success": True,
            "count": len(task_list),
            "tasks": task_list,
            "message": f"âœ… Found {len(task_list)} tasks"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Tasks error: {e}")
        return {"success": False, "error": str(e)}


def create_task(
    title: str,
    notes: str = "",
    due_date: str = None,
    task_list_id: str = "@default"
) -> dict:
    """
    Create a new task in Google Tasks.
    
    Args:
        title: Task title
        notes: Additional notes/description
        due_date: Due date in ISO format (e.g., "2025-12-15")
        task_list_id: Which task list to add to
    
    Returns:
        Dictionary with created task details
    """
    logger.info(f"[TOOL] create_task: {title}")
    
    try:
        service = _get_service('tasks', 'v1')
        
        task_body = {
            'title': title,
            'notes': notes,
        }
        
        if due_date:
            # Google Tasks wants RFC 3339 format
            if 'T' not in due_date:
                due_date = due_date + 'T00:00:00.000Z'
            task_body['due'] = due_date
        
        task = service.tasks().insert(
            tasklist=task_list_id,
            body=task_body
        ).execute()
        
        logger.info(f"[TOOL] Task created: {task.get('id')}")
        
        return {
            "success": True,
            "task_id": task.get('id'),
            "title": task.get('title'),
            "status": task.get('status'),
            "due": task.get('due', 'No due date'),
            "message": f"âœ… Task '{title}' created!"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Create task error: {e}")
        return {"success": False, "error": str(e)}


def complete_task(task_id: str, task_list_id: str = "@default") -> dict:
    """
    Mark a task as completed.
    
    Args:
        task_id: ID of the task to complete
        task_list_id: Task list containing the task
    
    Returns:
        Dictionary with completion status
    """
    logger.info(f"[TOOL] complete_task: {task_id}")
    
    try:
        service = _get_service('tasks', 'v1')
        
        # Get the task first
        task = service.tasks().get(
            tasklist=task_list_id,
            task=task_id
        ).execute()
        
        # Update status to completed
        task['status'] = 'completed'
        
        updated = service.tasks().update(
            tasklist=task_list_id,
            task=task_id,
            body=task
        ).execute()
        
        return {
            "success": True,
            "task_id": updated.get('id'),
            "title": updated.get('title'),
            "status": updated.get('status'),
            "message": f"âœ… Task '{updated.get('title')}' marked as complete!"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Complete task error: {e}")
        return {"success": False, "error": str(e)}


# =============================================================================
# GOOGLE PHOTOS API
# Note: Photos Library API requires Google verification for production apps.
# For unverified apps, you need to add photoslibrary scope manually.
# =============================================================================

def search_google_photos(query: str, max_results: int = 10) -> dict:
    """
    Search Google Photos for images matching a query.
    
    Args:
        query: Search term (e.g., "driver's license", "passport", "receipt")
        max_results: Maximum number of photos to return
    
    Returns:
        Dictionary with found photos or helpful message if API unavailable
    """
    logger.info(f"[TOOL] search_google_photos: query='{query}'")
    
    try:
        service = _get_service('photoslibrary', 'v1')
        
        # Search using content filter
        results = service.mediaItems().search(
            body={
                "pageSize": max_results,
                "filters": {
                    "contentFilter": {
                        "includedContentCategories": ["DOCUMENTS", "RECEIPTS"]
                    }
                }
            }
        ).execute()
        
        items = results.get('mediaItems', [])
        
        if not items:
            results = service.mediaItems().list(pageSize=max_results).execute()
            items = results.get('mediaItems', [])
        
        photos = []
        for item in items:
            photos.append({
                "id": item['id'],
                "filename": item.get('filename', ''),
                "description": item.get('description', ''),
                "mimeType": item.get('mimeType', ''),
                "creationTime": item.get('mediaMetadata', {}).get('creationTime', ''),
                "baseUrl": item.get('baseUrl', ''),
                "productUrl": item.get('productUrl', '')
            })
        
        return {
            "success": True,
            "count": len(photos),
            "query": query,
            "photos": photos,
            "message": f"ðŸ“¸ Found {len(photos)} photos" if photos else "No photos found"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        error_str = str(e)
        if "insufficient authentication scopes" in error_str.lower() or "403" in error_str:
            return {
                "success": False,
                "error": "Photos API requires additional setup",
                "message": "ðŸ“¸ Google Photos access is not available. The Photos Library API requires Google verification for sensitive scopes.",
                "alternatives": [
                    "You can access your photos directly at https://photos.google.com",
                    "Search for documents in your Google Drive instead",
                    "The Calendar, Gmail, and Tasks features are fully functional!"
                ],
                "help": "To enable Photos: Your Google Cloud project needs verification, or you can try adding the photoslibrary scope to your OAuth consent screen's test scopes."
            }
        logger.error(f"[TOOL] Photos search error: {e}")
        return {"success": False, "error": str(e)}


def list_photo_albums() -> dict:
    """
    List all albums in Google Photos.
    
    Returns:
        Dictionary with albums or error message if unavailable
    """
    logger.info("[TOOL] list_photo_albums")
    
    try:
        service = _get_service('photoslibrary', 'v1')
        
        results = service.albums().list(pageSize=20).execute()
        albums = results.get('albums', [])
        
        album_list = []
        for album in albums:
            album_list.append({
                "id": album['id'],
                "title": album.get('title', 'Untitled'),
                "mediaItemsCount": album.get('mediaItemsCount', 0),
                "productUrl": album.get('productUrl', '')
            })
        
        return {
            "success": True,
            "count": len(album_list),
            "albums": album_list,
            "message": f"ðŸ“ Found {len(album_list)} albums"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        error_str = str(e)
        if "insufficient authentication scopes" in error_str.lower() or "403" in error_str:
            return {
                "success": False,
                "message": "ðŸ“¸ Google Photos access requires additional setup. Visit https://photos.google.com directly.",
                "alternatives": ["Access photos at https://photos.google.com"]
            }
        logger.error(f"[TOOL] Albums error: {e}")
        return {"success": False, "error": str(e)}


def get_photos_from_album(album_id: str, max_results: int = 25) -> dict:
    """
    Get photos from a specific album.
    
    Args:
        album_id: The album ID to fetch photos from
        max_results: Maximum photos to return
    
    Returns:
        Dictionary with photos in the album
    """
    logger.info(f"[TOOL] get_photos_from_album: {album_id}")
    
    try:
        service = _get_service('photoslibrary', 'v1')
        
        results = service.mediaItems().search(
            body={
                "albumId": album_id,
                "pageSize": max_results
            }
        ).execute()
        
        items = results.get('mediaItems', [])
        
        photos = []
        for item in items:
            photos.append({
                "id": item['id'],
                "filename": item.get('filename', ''),
                "description": item.get('description', ''),
                "mimeType": item.get('mimeType', ''),
                "baseUrl": item.get('baseUrl', ''),
                "width": item.get('mediaMetadata', {}).get('width', ''),
                "height": item.get('mediaMetadata', {}).get('height', '')
            })
        
        return {
            "success": True,
            "count": len(photos),
            "album_id": album_id,
            "photos": photos,
            "message": f"ðŸ“¸ Found {len(photos)} photos in album"
        }
        
    except FileNotFoundError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"[TOOL] Album photos error: {e}")
        return {"success": False, "error": str(e)}


# =============================================================================
# UTILITY: Get current datetime
# =============================================================================

def get_current_datetime() -> dict:
    """
    Get the current date and time.
    
    Returns:
        Dictionary with current datetime information
    """
    now = datetime.now()
    
    return {
        "datetime": now.isoformat(),
        "date": now.strftime("%A, %B %d, %Y"),
        "time": now.strftime("%I:%M %p"),
        "timezone": "Local",
        "is_weekend": now.weekday() >= 5
    }
